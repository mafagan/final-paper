\chapter{解释集生成与嵌入更新}
在上一章中，我们给出了在知识库中进行诊断的基本框架，并且详细地对相关的定理进行了证明。但是我们还没有完成从解释集到嵌入向量的翻译，以及实际的求解算法，因此，在本章当中，我们先给出从解释生成解释训练集的方法，接着给出在解释训练集到嵌入向量的一般性算法。 

\section{决断集计算}

	基于决断集模版的解释需要特定的决断集模版的集合。在上一章的命题中我们展示了生成决断集模版的方法，我们首先计算本体中所有的原子蕴含值，接着根据蕴含值我们计算出所有蕴含值的决断集，最后通过$lift$操作生成决断集模版变量。然而，这种方法并不完全可行，因为计算所有蕴含值的决断集是非常耗时的\cite{KPHS07}。所以我们提出了新的计算决断集的方法。
	
	这种方法是从一种高效的方法改进而来\cite{DQF14}，我们首先计算所有导致本体不一致的本体最小子集，通过逐条递增的方式计算决断集模版，这种方式使用了更有效地剪枝技术和分治策略，以最大程度避免对相同类型的决断集进行重复计算。
	
	在以下算法中，我们以形如$A \sqsubseteq B$的蕴含值为例，我们对于所有的原子蕴含值进行顺序求解。例如，对于所有由本体$\mathcal{O}$蕴含的形如$A \sqsubseteq B$，我们，它首先计算所有对于$X \sqsubseteq Y$的决断集模版。
	利用\cite{DQF14}中的搜索方法，它可以递增地计算新的决断集。
	
	\begin{algorithm}
  \caption{决断集模版的计算方法}
  \KwIn{Ontology $\mathcal{O}$}

  $\mathcal{P}\gets \emptyset $ \ \ //$\mathcal{P}$存储所有的决断集模版\
		

	\For{each ACIs $A \sqsubseteq B$ entailed by $\mathcal{O}$}
	{
		$\mathcal{S} \gets \{\mathcal{J}_p\theta\mid \mathcal{J}_p\in \mathcal{P}$,
   $\theta$ is a differentiated substitution for $\mathcal{J}_p$ such that
   $X\theta=A$, $Y\theta=B$, $\mathcal{J}_p\theta\subseteq \mathcal{O}$ and $\mathcal{J}\not\models A\sqsubseteq B$ for
   all $\mathcal{J}\in subs_1(\mathcal{J}_p\theta)\}$\;
		\While{$\mathcal{S}=\emptyset$ (then $H$ is set as $\emptyset$) or
   there is a minimal hitting set $H$ for $\mathcal{S}$ such that $\mathcal{T}\setminus H\models A\sqsubseteq B$}
		{
			$\mathcal{J}\gets$ FindJustification($\emptyset$, $\mathcal{O}\setminus H$, $A\sqsubseteq B$) \;
			$\mathcal{J}_p\gets lift(\mathcal{J},A,B)$
			
			$\mathcal{P}\gets\mathcal{P}\cup \{\mathcal{J}_p\}$\;
			$\mathcal{S}\gets \mathcal{S}\cup \{\mathcal{J}_p\theta\mid \theta$ is a differentiated substitution for $\mathcal{J}_p$ such that
   $X\theta=A$, $Y\theta=B$, $\mathcal{J}_p\theta\subseteq \mathcal{O}$ and $\mathcal{J}\not\models A\sqsubseteq B$ for all
   $\mathcal{J}\in subs_1(\mathcal{J}_p\theta)\}$\;
		}
	}
	\Return $\mathcal{P}$\;
	
	$\textbf{FindJustification}$($S_u$, $S_c$, $A\sqsubseteq B$) //返回一个$S_c$的最小子集$S$使得$S_u\cup S\models A\sqsubseteq B$\;
	
	\If{$S_c=\emptyset$ or $S_u\models A\sqsubseteq B$}
	{
		\Return $\emptyset$
	}
	
	\If{$|S_c|=1$}
	{
		\Return $S_c$
	}
	
	Divide $S_c$ into two disjoint subsets $S_1$ and $S_2$ such that
 $S_1\cup S_2=S_c$, $S_1\cap S_2=\emptyset$ and $0\leq |S_1|-|S_2|\leq 1$\;
 
 $\Delta_2\gets$ FindJustification($S_u\cup S_1$, $S_2$, $A\sqsubseteq B$)\;
 
 $\Delta_1\gets$ FindJustification($S_u\cup \Delta_2$, $S_1$, $A\sqsubseteq B$)\;
 
 \Return $\Delta_1\cup\Delta_2$

\end{algorithm}
	
	\begin{definition}[最小碰集)]
    一个集合$H$如果满足条件：在一个由公里集组成的集合$\mathcal{S}$里，如果对于所有的$S \in \mathcal{S}$有$H \cap S \not = \emptyset$，且$H$是最小集，那么这个$H$就被称为$\mathcal{S}$的最小碰集(MHS)。
	\end{definition}
	
	
	根据最小碰集的特点，我们可以判断如果存在一个决断集集合的最小碰集$H$使得$\mathcal{O} \setminus H \models A \sqsubseteq B$，一个新的决断集可以从集合$\mathcal{O} \setminus H$中通过分治法得到\cite{DQF14}。
	
	根据以上算法，我们给出以下例子：
	
	\begin{example}
		这个例子主要叙述如何使用算法3在本体$\mathcal{O}$进行运算，其中$\mathcal{O}$包含以下六条公理：
		
		$$ \mathcal{O}=\left\{
		\begin{aligned}
		\alpha_1: A \sqsubseteq \exists r.C \ \  \alpha_2: A \sqsubseteq B \sqcup C \\
		\alpha_3: A \sqcap C \sqsubseteq \bot \ \  \alpha_4: C \sqsubseteq D \\
		\alpha_5: \exists r.D \sqsubseteq B \ \  \alpha_6: D \sqsubseteq E
		\end{aligned}
	\right\}.
	$$
	
	可以得到其中$A \sqsubseteq B$可由$\mathcal{O}$蕴含。我们以$A \sqsubseteq B$为例进行运算，第一轮运算中，我们使用$\textbf{FindJustification}(\emptyset, \mathcal{O}, A \sqsubseteq B)$计算第一个决断集。我们把$\mathcal{O}$划分为$S_1=\{\alpha_1, \alpha_2, \alpha_3\}$以及$S_2=\{\alpha_4, \alpha_5, \alpha_6\}$。通过递归调用$\textbf{FindJustification}(S_1,S_2,A \sqsubseteq B)$，我们得到$\Delta_2 = \emptyset$。又通过递归调用$\textbf{FindJustification}(\Delta_2,S_1,A \sqsubseteq B)$，我们可以得到$\Delta_1=\{\alpha_2, \alpha_3\}$。所以$A \sqsubseteq B$的第一个决断集是$\mathcal{J}_1 =\{\alpha_2, \alpha_3\}$。通过$lift\{\mathcal{J}_1\}$，我们得到第一个$X\sqsubseteq Y$的决断集模版$\mathcal{J}_{p1} =\{X \sqsubseteq Y \sqcup Z_C,X \sqcap Z_C \sqsubseteq \bot \}$。由于无法在本体$\mathcal{O}$中找到可实例化的决断集，我们计算$\mathcal{J}_1$的MHS $H$，令$H = \{\alpha_2\}$使得$\mathcal{O} \setminus H \models A \sqsubseteq B$。我们继续调用$\textbf{FindJustification}(\emptyset,\mathcal{O}\setminus H,A \sqsubseteq B)$得到第二个决断集$\mathcal{J}_2 = \{\alpha_1, \alpha_4, \alpha_5\}$。由于不存在$\{\mathcal{J}_1, \mathcal{J}_2\}$的MHS $H$使得$\mathcal{O} \setminus H \models A \sqsubseteq B$，我们已经得到全部的决断集$\{\mathcal{J}_1, \mathcal{J}_2\}$。
	\end{example}
	
	
\section{多观察值的最小解释集生成}
	针对知识库多观察值的特点，我们在对于单个观察值的解释的基础上还对多观察值的情况进行求解。实际上，对多观察值的解释进行求解可以在分别求解单个观察值解释的基础上继续进行求解。我们把由多观察值构成的本体记作$\mathcal{O}_{\phi}$并有如下定义：
	
	\begin{definition}[状态蕴含)]
		如果对于所有的在$\mathcal{O}_{\phi}$中的公理$\alpha$满足$\mathcal{O} \models \alpha$，我们就称$\mathcal{O}$状态蕴含$\mathcal{O}_{\phi}$，记作$\mathcal{O} \models_{S} \mathcal{O}_{\phi}$。
	\end{definition}
	
	我们令$\mathcal{S}_{\mathcal{E}}$为$\mathcal{O}_{\phi}$中所有观察值$\alpha$的解释集集合。由算法3我们知道在解释集的生成过程中，我们需要多次地执行返回一个$S_c$的最小子集$S$使得$S_u\cup S\models A\sqsubseteq B$的运算，因此可以知道计算$\mathcal{O}_{\phi}$的最小解释集其实是决断集生成算法逻辑上的一个子任务，因此我们根据决断集生成算法提出了多观察值的最小解释集计算方法。
	
	
	\begin{algorithm}
  \caption{多观察值的最小解释集生成}
  \KwIn{Ontology $\mathcal{O}$，observation ontology $\mathcal{O}_{\phi}$，explanation set $\mathcal{S}_{\mathcal{E}}$}

	\Return $\textbf{FindMinimalExp}$($\mathcal{O}$, $\mathcal{S}_{\mathcal{E}}$, $\mathcal{O}_{\phi}$) \;
	$\textbf{FindMinimalExp}$($S_u$, $S_c$, $\mathcal{O}$) //返回一个$S_c$的最小子集$S$使得$S_u\cup S\models_{S} \mathcal{O}$\;
	
	\If{$S_c=\emptyset$ or $S_u\models_S \mathcal{O}$}
	{
		\Return $\emptyset$
	}
	
	\If{$|S_c|=1$}
	{
		\Return $S_c$
	}
	
	Divide $S_c$ into two disjoint subsets $S_1$ and $S_2$ such that
 $S_1\cup S_2=S_c$, $S_1\cap S_2=\emptyset$ and $0\leq |S_1|-|S_2|\leq 1$\;
 
 $\Delta_2\gets$ FindMinimalExp($S_u\cup S_1$, $S_2$, $\mathcal{O}$)\;
 
 $\Delta_1\gets$ FindMinimalExp($S_u\cup \Delta_2$, $S_1$, $\mathcal{O}$)\;
 
 \Return $\Delta_1\cup\Delta_2$

\end{algorithm}
	